/**
 * Private Data Sync Service
 * 
 * Optional service to sync user data to a private git repository for AI assistance.
 * This is OPT-IN ONLY and requires explicit user configuration.
 * 
 * Privacy: All syncing is opt-in, encrypted, and user-controlled.
 */

import * as fs from 'fs';
import * as path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';
import * as crypto from 'crypto';

const execAsync = promisify(exec);

export interface PrivateSyncConfig {
  enabled: boolean;
  repositoryUrl?: string;
  repositoryPath?: string; // Local path to private repo
  branch?: string;
  encryptionKey?: string; // For encrypting sensitive data
  syncInterval?: number; // Minutes between syncs
  includeCheckpoints?: boolean;
  includeCache?: boolean;
  includeReports?: boolean;
  includeLogs?: boolean;
  excludePatterns?: string[]; // Patterns to exclude even if category is included
}

export interface SyncResult {
  success: boolean;
  syncedFiles: string[];
  skippedFiles: string[];
  errors: string[];
  lastSync?: Date;
}

/**
 * Private Data Sync Manager
 * 
 * Syncs user data to a private git repository for AI assistance.
 * All syncing is opt-in and requires explicit configuration.
 */
export class PrivateDataSync {
  private config: PrivateSyncConfig;
  private repoPath: string;
  private syncInterval?: NodeJS.Timeout;
  private encryptionKey?: Buffer;

  constructor(config: PrivateSyncConfig, repositoryRoot: string = process.cwd()) {
    // Merge with defaults, but config.enabled takes precedence
    const defaults = {
      branch: 'main',
      syncInterval: 60, // 60 minutes default
      includeCheckpoints: true,
      includeCache: false, // Cache is usually not needed
      includeReports: true,
      includeLogs: false, // Logs can be large
      excludePatterns: [],
    };
    
    this.config = {
      ...defaults,
      ...config,
      enabled: config.enabled, // Ensure enabled from config is used
    };

    // Resolve repository path
    if (this.config.repositoryPath) {
      this.repoPath = path.resolve(this.config.repositoryPath);
    } else if (this.config.repositoryUrl) {
      // Clone to .maestro/private-sync if URL provided
      this.repoPath = path.join(repositoryRoot, '.maestro', 'private-sync');
    } else {
      throw new Error('Either repositoryUrl or repositoryPath must be provided');
    }

    // Setup encryption key if provided
    if (this.config.encryptionKey) {
      this.encryptionKey = crypto.createHash('sha256').update(this.config.encryptionKey).digest();
    }
  }

  /**
   * Initialize the private repository
   */
  async initialize(): Promise<void> {
    if (!this.config.enabled) {
      return;
    }

    // Clone repository if URL provided and doesn't exist
    if (this.config.repositoryUrl && !fs.existsSync(this.repoPath)) {
      console.log('üì• Cloning private sync repository...');
      await execAsync(`git clone ${this.config.repositoryUrl} "${this.repoPath}"`);
    }

    // Ensure repository exists
    if (!fs.existsSync(this.repoPath)) {
      throw new Error(`Repository path does not exist: ${this.repoPath}`);
    }

    // Setup .gitignore in sync repo to track what we want
    const gitignorePath = path.join(this.repoPath, '.gitignore');
    if (!fs.existsSync(gitignorePath)) {
      fs.writeFileSync(gitignorePath, '# Auto-generated by Maestro\n*.tmp\n*.lock\n');
    }

    // Start periodic sync if interval configured
    if (this.config.syncInterval && this.config.syncInterval > 0) {
      this.startPeriodicSync();
    }
  }

  /**
   * Sync user data to private repository
   */
  async sync(repositoryRoot: string = process.cwd()): Promise<SyncResult> {
    if (!this.config.enabled) {
      return {
        success: false,
        syncedFiles: [],
        skippedFiles: [],
        errors: ['Sync is disabled'],
      };
    }

    const result: SyncResult = {
      success: true,
      syncedFiles: [],
      skippedFiles: [],
      errors: [],
    };

    try {
      // Ensure repo is up to date
      await this.pullLatest();

      // Sync each category if enabled
      if (this.config.includeCheckpoints) {
        await this.syncCategory('checkpoints', repositoryRoot, result);
      }

      if (this.config.includeCache) {
        await this.syncCategory('cache', repositoryRoot, result);
      }

      if (this.config.includeReports) {
        await this.syncCategory('reports', repositoryRoot, result);
      }

      if (this.config.includeLogs) {
        await this.syncCategory('logs', repositoryRoot, result);
      }

      // Commit and push changes
      if (result.syncedFiles.length > 0) {
        await this.commitAndPush(result.syncedFiles);
        result.lastSync = new Date();
      }

      return result;
    } catch (error: any) {
      result.success = false;
      result.errors.push(error.message || 'Unknown error');
      return result;
    }
  }

  /**
   * Sync a specific category of data
   */
  private async syncCategory(
    category: 'checkpoints' | 'cache' | 'reports' | 'logs',
    repositoryRoot: string,
    result: SyncResult
  ): Promise<void> {
    const sourceDir = path.join(repositoryRoot, '.maestro', category);
    const destDir = path.join(this.repoPath, category);

    if (!fs.existsSync(sourceDir)) {
      return; // Nothing to sync
    }

    // Ensure destination directory exists
    if (!fs.existsSync(destDir)) {
      fs.mkdirSync(destDir, { recursive: true });
    }

    // Copy files
    const files = fs.readdirSync(sourceDir);
    for (const file of files) {
      // Check exclude patterns
      if (this.shouldExclude(file)) {
        result.skippedFiles.push(`${category}/${file}`);
        continue;
      }

      const sourcePath = path.join(sourceDir, file);
      const destPath = path.join(destDir, file);

      // Skip directories
      if (fs.statSync(sourcePath).isDirectory()) {
        continue;
      }

      try {
        // Read source file
        let content = fs.readFileSync(sourcePath, 'utf-8');

        // Encrypt if encryption enabled
        if (this.encryptionKey && this.isSensitive(category, file)) {
          content = this.encrypt(content);
          // Add .encrypted extension
          const encryptedPath = destPath + '.encrypted';
          fs.writeFileSync(encryptedPath, content, 'utf-8');
        } else {
          fs.writeFileSync(destPath, content, 'utf-8');
        }

        result.syncedFiles.push(`${category}/${file}`);
      } catch (error: any) {
        result.errors.push(`Failed to sync ${category}/${file}: ${error.message}`);
      }
    }
  }

  /**
   * Check if file should be excluded
   */
  private shouldExclude(file: string): boolean {
    if (!this.config.excludePatterns) {
      return false;
    }

    return this.config.excludePatterns.some(pattern => {
      // Simple glob matching
      const regex = new RegExp(pattern.replace(/\*/g, '.*'));
      return regex.test(file);
    });
  }

  /**
   * Check if data is sensitive and should be encrypted
   */
  private isSensitive(category: string, file: string): boolean {
    // Encrypt checkpoints and cache (contain execution state)
    if (category === 'checkpoints' || category === 'cache') {
      return true;
    }

    // Encrypt reports that might contain code snippets
    if (category === 'reports' && file.includes('execution')) {
      return true;
    }

    return false;
  }

  /**
   * Encrypt content
   */
  private encrypt(content: string): string {
    if (!this.encryptionKey) {
      return content;
    }

    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv('aes-256-cbc', this.encryptionKey, iv);
    let encrypted = cipher.update(content, 'utf-8', 'hex');
    encrypted += cipher.final('hex');
    return iv.toString('hex') + ':' + encrypted;
  }

  /**
   * Pull latest changes from repository
   */
  private async pullLatest(): Promise<void> {
    try {
      await execAsync(`git -C "${this.repoPath}" pull origin ${this.config.branch || 'main'}`);
    } catch (error: any) {
      // Ignore errors if repo is new or has no remote
      if (!error.message.includes('no such file') && !error.message.includes('No remote')) {
        throw error;
      }
    }
  }

  /**
   * Commit and push changes
   */
  private async commitAndPush(files: string[]): Promise<void> {
    // Add all files
    await execAsync(`git -C "${this.repoPath}" add -A`);

    // Commit
    const message = `Sync user data: ${files.length} file(s) - ${new Date().toISOString()}`;
    await execAsync(`git -C "${this.repoPath}" commit -m "${message}"`);

    // Push
    try {
      await execAsync(`git -C "${this.repoPath}" push origin ${this.config.branch || 'main'}`);
    } catch (error: any) {
      // If push fails, that's okay - user can push manually
      console.warn('‚ö†Ô∏è  Failed to push to remote. Changes are committed locally.');
    }
  }

  /**
   * Start periodic sync
   */
  private startPeriodicSync(): void {
    if (this.syncInterval) {
      clearInterval(this.syncInterval);
    }

    const intervalMs = (this.config.syncInterval || 60) * 60 * 1000;
    this.syncInterval = setInterval(() => {
      this.sync().catch(error => {
        console.error('‚ùå Periodic sync failed:', error.message);
      });
    }, intervalMs);
  }

  /**
   * Stop periodic sync
   */
  stop(): void {
    if (this.syncInterval) {
      clearInterval(this.syncInterval);
      this.syncInterval = undefined;
    }
  }

  /**
   * Get sync status
   */
  async getStatus(): Promise<{
    enabled: boolean;
    repositoryPath: string;
    lastSync?: Date;
    pendingChanges: number;
  }> {
    if (!this.config.enabled) {
      return {
        enabled: false,
        repositoryPath: this.repoPath,
        pendingChanges: 0,
      };
    }

    try {
      const { stdout } = await execAsync(`git -C "${this.repoPath}" status --porcelain`);
      const pendingChanges = stdout.split('\n').filter(line => line.trim()).length;

      return {
        enabled: true,
        repositoryPath: this.repoPath,
        pendingChanges,
      };
    } catch (error) {
      return {
        enabled: true,
        repositoryPath: this.repoPath,
        pendingChanges: 0,
      };
    }
  }
}
