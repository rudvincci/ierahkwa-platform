# Agent Orchestrator - Cursor Rules

## Overview

The Agent Orchestrator (`.agent-orchestrator/`) is a production-grade CLI tool for coordinating multiple AI agents through workflow definitions. It integrates with Cursor CLI to execute tasks across different agent roles in a structured, dependency-aware manner.

## Key Capabilities

### 1. Parallel Execution
- Independent tasks can run simultaneously
- Automatic detection of parallelizable steps
- Configurable concurrency limits via `--max-concurrency`

### 2. Nested Workflows
- Workflows can execute other workflows as sub-workflows
- Context inheritance from parent workflows
- Hierarchical task organization

### 3. Dynamic Task Spawning
- Tasks can conditionally create sub-tasks based on results
- Enables adaptive workflows
- Condition evaluation based on previous task results

## When to Use Agent Orchestrator

### Use Orchestrator When:
- **Complex Multi-Step Workflows**: Features requiring multiple specialized agents (Architect → Backend → Frontend → Tests)
- **Parallel Execution Needed**: Independent tasks that can run simultaneously
- **Reusable Workflows**: Common patterns (e.g., feature implementation) that repeat
- **Automated Agent Coordination**: Need to coordinate multiple Cursor CLI calls with dependencies
- **Structured Execution**: Want execution plans, logging, and error handling

### Use Direct Cursor CLI When:
- **Simple Single Tasks**: One-off tasks that don't need coordination
- **Interactive Development**: Working directly with Composer/Chat
- **Quick Prototypes**: Rapid iteration without workflow overhead

## How Cursor CLI Integration Works

The orchestrator uses Cursor CLI in headless mode:

```bash
cursor-agent -p --force --output-format json "<prompt>"
```

**Key Points:**
- Each workflow step calls `cursor-agent` once with a role-specific prompt
- Prompts include role context, domain knowledge, and previous step results
- Results are parsed and passed to subsequent steps
- Parallel steps execute concurrently (with concurrency limits)

## Available Agent Roles

1. **Architect** - System design, DDD patterns, microservice design
2. **Backend** - .NET microservice implementation, CQRS, domain logic
3. **Frontend** - Blazor/Razor components, UI/UX implementation
4. **Rust** - Rust code for MameyNode
5. **Tests** - Unit, integration, E2E tests
6. **Docs** - Quick documentation, README updates
7. **TechnicalWriter** - Comprehensive technical documentation
8. **Infrastructure** - Docker, Kubernetes, CI/CD
9. **Contracts** - API contracts, DTOs, shared interfaces
10. **Events** - Event definitions, handlers, saga orchestration
11. **Database** - Migrations, schema changes, persistence
12. **Security** - Authentication, authorization, compliance
13. **Integration** - Service integration, message brokers, external APIs

## Workflow Configuration

Workflows are defined in YAML (`config/orchestration.yml` or `config/orchestration-enhanced.yml`):

```yaml
flows:
  feature_implementation:
    steps:
      - name: ArchitecturePlan
        agent: Architect
        description: Analyze requirements
        dependsOn: []
        parallel: true  # Can run in parallel
        
      - name: BackendImplementation
        agent: Backend
        description: Implement backend
        dependsOn: [ArchitecturePlan]
        nestedWorkflow: backend_workflow  # Execute nested workflow
        
      - name: FrontendImplementation
        agent: Frontend
        description: Implement frontend
        dependsOn: [BackendImplementation]
        spawnTasks:  # Dynamically create sub-tasks
          - condition: "previousResult.success === true"
            agent: Tests
            description: Create frontend tests
```

## CLI Usage

### Basic Commands

```bash
# List available workflows and agents
cd .agent-orchestrator
npm run dev flows

# Dry-run (preview execution plan)
npm run dev run --flow feature_implementation --dry-run

# Execute with dummy runner (testing)
npm run dev run --flow feature_implementation --runner dummy

# Execute with Cursor CLI
npm run dev run --flow feature_implementation --runner cursor --feature "Add user auth"

# With parallel execution and concurrency limit
npm run dev run --flow parallel_feature_implementation --max-concurrency 3

# Continue on error (default: true)
npm run dev run --flow my_workflow --continue-on-error

# Abort on first error
npm run dev run --flow my_workflow --abort-on-error
```

### Configuration Options

- `--config <path>` - Custom config file path
- `--max-concurrency <number>` - Limit parallel executions
- `--continue-on-error` - Continue even if tasks fail
- `--abort-on-error` - Abort workflow on first error
- `--feature <description>` - Feature description for prompts
- `--log-level <level>` - Logging level (info|debug|warn|error)
- `--output <dir>` - Output directory for logs

## Integration with Cursor Composer/Chat

### When Working in Cursor IDE:

1. **For Complex Features**: Use orchestrator to coordinate multiple agents
   ```
   "Run the feature_implementation workflow for adding user authentication"
   ```

2. **For Simple Tasks**: Use Composer/Chat directly
   ```
   "Add a new endpoint to the Users controller"
   ```

3. **For Workflow Creation**: Ask Composer to create/update workflows
   ```
   "Create a workflow for implementing a new microservice with all layers"
   ```

### Best Practices:

- **Use Orchestrator** for multi-agent coordination with dependencies
- **Use Composer** for interactive development and quick changes
- **Use Chat** for questions and documentation
- **Combine Both**: Use orchestrator for structure, Composer for refinement

## Prompt Building

The orchestrator builds comprehensive prompts for each agent role:

1. **Role Context**: Agent role description and responsibilities
2. **Prompt Hints**: Role-specific instructions and patterns
3. **Feature Context**: Feature description (if provided)
4. **Task Description**: Specific task for this step
5. **Previous Results**: Results from dependent steps
6. **File Patterns**: Relevant file patterns for the role
7. **Domain Knowledge**: Relevant domains (Government, Banking, etc.)
8. **Mamey Framework Context**: Framework-specific patterns

## Error Handling

- **Continue on Error**: Default behavior - continues execution even if tasks fail
- **Abort on Error**: Stops workflow on first failure
- **Error Logging**: All errors logged to `.agent-orchestrator/logs/{runId}.json`
- **Result Tracking**: Failed tasks tracked separately from completed tasks

## Limitations

1. **Sequential by Default**: Steps execute sequentially unless marked `parallel: true`
2. **Single CLI Call per Step**: Each step = one `cursor-agent` call
3. **No True Subagents**: Simulates multiple agents via multiple CLI calls
4. **Condition Evaluation**: Basic JavaScript eval (consider safer evaluator for production)
5. **Nested Context**: Nested workflows share parent context (not isolated)

## Future Enhancements

- Safer condition evaluator (expression parser)
- Isolated execution contexts for nested workflows
- Parallel execution of spawned tasks
- Agent-to-agent communication protocols
- Workflow templates and composition
- Real-time progress tracking for parallel tasks

## Documentation

- **README**: `.agent-orchestrator/docs/README.md`
- **Subagent Capabilities**: `.agent-orchestrator/docs/SUBAGENT_CAPABILITIES.md`
- **Changelog**: `.agent-orchestrator/CHANGELOG_SUBAGENTS.md`
- **Enhanced Config**: `.agent-orchestrator/config/orchestration-enhanced.yml`

## Quick Reference

**Project Root**: `.agent-orchestrator/`
**Config**: `config/orchestration.yml` or `config/orchestration-enhanced.yml`
**Logs**: `logs/{runId}.json`
**Build**: `npm run build`
**Dev**: `npm run dev <command>`

**Key Files**:
- `src/workflow/EnhancedWorkflowExecutor.ts` - Main executor with subagent capabilities
- `src/workflow/ParallelDependencyResolver.ts` - Parallel execution resolver
- `src/agents/CursorCliAgentRunner.ts` - Cursor CLI integration
- `src/agents/PromptBuilder.ts` - Prompt construction
